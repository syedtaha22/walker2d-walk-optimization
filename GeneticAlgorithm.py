import numpy as np
import random

class GeneticAlgorithm:
    """
    Implements a genetic algorithm for evolving keyframe-based movement strategies.

    This class provides methods for selection, crossover, and mutation to evolve a population 
    of individuals, each representing a set of keyframe-based actions and durations.

    Attributes:
        population_size (int): The number of individuals in the population.
        mutation_rate (float): The probability of mutating an individual.
        mutation_magnitude (float): The standard deviation of Gaussian noise applied during mutation.
    """

    def __init__(self, population_size=20, mutation_rate=0.1, mutation_magnitude=0.3):
        """
        Initializes the genetic algorithm with population size, mutation rate, and mutation magnitude.

        Args:
            population_size (int): The number of individuals in the population. Default is 20.
            mutation_rate (float): The probability of an individual undergoing mutation. Default is 0.1.
            mutation_magnitude (float): The standard deviation of Gaussian noise applied during mutation. Default is 0.3.
        """
        self.population_size = population_size
        self.mutation_rate = mutation_rate
        self.mutation_magnitude = mutation_magnitude

    def tournament_selection(self, population, fitnesses):
        """
        Selects an individual from the population using tournament selection.

        Two individuals are randomly chosen from the population, and the one with the higher fitness 
        is selected.

        Args:
            population (list of np.ndarray): The current population of individuals.
            fitnesses (list of float): The fitness scores corresponding to each individual.

        Returns:
            np.ndarray: The selected individual.
        """
        idx1, idx2 = np.random.choice(len(population), 2, replace=False)
        return population[idx1] if fitnesses[idx1] > fitnesses[idx2] else population[idx2]

    def keyframe_swap_crossover(self, parent1, parent2):
        """
        Performs crossover by swapping a segment of keyframes between two parents.

        A random segment of keyframes from `parent2` is inserted into `parent1`, producing a child.

        Args:
            parent1 (np.ndarray): The first parent individual.
            parent2 (np.ndarray): The second parent individual.

        Returns:
            np.ndarray: The child individual created from crossover.
        """
        point1, point2 = sorted(np.random.choice(len(parent1), 2, replace=False))
        child = parent1.copy()
        child[point1:point2] = parent2[point1:point2]
        return child

    def blxalpha_crossover(self, parent1, parent2, alpha=0.3):
        """
        Performs Blend Crossover (BLX-α) between two parents.

        This crossover generates a child by blending action values of two parents within a 
        range influenced by `alpha`. The duration values are inherited randomly from one of the parents.

        Args:
            parent1 (np.ndarray): The first parent individual.
            parent2 (np.ndarray): The second parent individual.
            alpha (float): The blending factor controlling the range of values. Default is 0.3.

        Returns:
            np.ndarray: The child individual generated by BLX-α crossover.
        """
        child = np.empty_like(parent1)
        for i in range(len(parent1)):
            child[i, :-1] = (1 + alpha) * parent1[i, :-1] - alpha * parent2[i, :-1]  # Blended action values
        child[:, -1] = [random.choice([parent1[i, -1], parent2[i, -1]]) for i in range(len(parent1))]  # Random duration inheritance
        return child

    def mutate(self, individual):
        """
        Mutates an individual by applying Gaussian noise to actions and uniform noise to durations.

        The mutation is applied with probability `mutation_rate`. Action values receive Gaussian noise 
        with a standard deviation of `mutation_magnitude`, while duration values receive uniform noise.

        Args:
            individual (np.ndarray): The individual to be mutated.

        Returns:
            np.ndarray: The mutated individual.
        """
        if np.random.rand() < self.mutation_rate:
            noise = np.random.normal(0, self.mutation_magnitude, size=individual[:, :-1].shape)  # Gaussian noise for actions
            duration_noise = np.random.uniform(0, 10, size=individual[:, -1].shape)  # Uniform noise for durations
            individual[:, :-1] += noise
            individual[:, -1] += duration_noise
            individual = self.clip_keyframes(individual)  # Ensure values stay within valid ranges
        return individual

    def clip_keyframes(self, keyframes):
        """
        Clips keyframe values to valid ranges.

        - Action values are clipped to the range [-1, 1].
        - Duration values are clipped to the range [0, 100].

        Args:
            keyframes (np.ndarray): The keyframe data to be clipped.

        Returns:
            np.ndarray: The clipped keyframe data.
        """
        keyframes[:, :-1] = np.clip(keyframes[:, :-1], -1, 1)  # Clip actions
        keyframes[:, -1] = np.clip(keyframes[:, -1], 0, 100)  # Clip durations
        return keyframes
